---
title: "Block 1 Flash Cards"
link-citations: true
code-annotations: hover
params: 
    SHOW_SOLS: TRUE
    TOGGLE: TRUE
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
source('assets/setup.R')

# knitr::opts_chunk$set(cache = TRUE)
set.seed(1)

#packages
library(tidyverse)
library(sjPlot)
library(kableExtra)
library(psych)

#data
handheight <- read_csv(file = 'https://uoepsy.github.io/data/handheight.csv')
```

:::lo
### <i class="fa fa-graduation-cap"></i> Flash Card Aims

The purpose of these flashcards is to complement your Semester 1 Weeks 1 - 5 core learning materials i.e., your lecture and lab materials, by offering additional guidance and examples on key concepts/topics. It’s designed to deepen your understanding, clarify complex concepts, and help you make connections between different areas of study. Think of it as an extra resource that supports what you’re learning in the classroom. 

You may want to consider using the below as a supporting document whilst your work through lab exercises, and/or refer to in order to aid revision. 

### <i class="fab fa-r-project"></i> R Packages

Within this reading, the following packages are used:

* **tidyverse** 
* **sjPlot**
* **kableExtra**
* **psych**

### <i class="fa fa-pencil-square-o" aria-hidden="true"></i> Presenting Results
Note that you must **not** copy any of the write-ups included below for future reports - if you do, you will be committing plagiarism, and this type of academic misconduct is taken very seriously by the University. You can find out more [here](https://www.ed.ac.uk/academic-services/students/conduct/academic-misconduct).

:::

# Back to Basics

`r optbegin("Terminology", olabel=FALSE,toggle=params$TOGGLE)`

Let's spend some time to remind ourselves of some key terminology, specifically related to types of variables and study designs:


| Term           | Definition       |
|----------------|------------------|
| (Observational) unit | The individual entities on which data are collected |  
| Variable | Any characteristic recorded on the observational units |  
| Numeric variable | A variable that records a numerical quantity for each case. For such variables standard arithmetic operations make sense. For example: height, IQ, and weight |  
| Categorical variable | A categorical variable places units into one of several groups. For example: country of birth, dominant hand, and eye colour |  
| Binary variable | A special case of categorical variable with only 2 possible levels. For example: handedness (left or right), smoking status (smoker or non-smoker), pass test (yes or no) |  
| Response variable (also more commonly called a dependent variable, or outcome variable) | Measures the outcome of interest in a study |  
| Explanatory/independent variable (also called predictors) | Are used to explain differences/changes in the response variable |  
| Observational study | An observational study is a study in which the researcher does not manipulate any of the variables involved in the study, but merely records the values as they naturally exist | 
| Experimental study | An experiment is a study in which the researcher imposes the values of the explanatory variable on the units before measuring the response variable |  

:::{.callout-note}

If you are not comfortable with one (or more) of the terms, revisit the [DAPR1 materials](https://uoepsy.github.io/dapr1/2324/) for a refresher.

:::

`r optend()`


<div class="divider div-transparent div-dot"></div>

# Data Exploration

The common first port of call for almost any statistical analysis is to explore the data, and we can do this visually and/or numerically.

+----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                |  Marginal Distributions                                                                                                                                         | Bivariate Associations                                                                                                                                                       |
+================+=================================================================================================================================================================+==============================================================================================================================================================================+
|**Description** |  The distribution of each variable individually (i.e., *without* reference to the values of the other variables).                                                                     | Describing the association between two numeric variables.                                                                                                                    
+----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|**Visually**    | Plot each variable individually.                                                                                                                                | Plot associations among two variables.                                                                                                                                       |
|  <br>          | <br>                                                                                                                                                            | <br>                                                                                                                                                                         |
|  <br>          | <br>                                                                                                                                                            | <br>                                                                                                                                                                         |
|                | You could use, for example, `geom_density()` for a density plot or `geom_histogram()` for a histogram to comment on and/or examine:                             | You could use, for example, `geom_point()` for a scatterplot  to comment on and/or examine:                                                                                  |
|  <br>          | <br>                                                                                                                                                            | <br>                                                                                                                                                                         |
|  <br>          | <br>                                                                                                                                                            | <br>                                                                                                                                                                         |
|                |<ul><li> The *shape* of the distribution. Look at the shape, centre and spread of the distribution. Is it symmetric or skewed? Is it unimodal or bimodal? </li>  | <li>The *direction* of the association indicates whether there is a positive or negative association  </li>                                                                  |
|                |<li> Identify any *unusual observations*. Do you notice any extreme observations (i.e., outliers)? </li>                                                         | <li>The *form* of association refers to whether the relationship between the variables can be summarized well with a straight line or some more complicated pattern </li>    |
|                |                                                                                                                                                                 | <li>The *strength* of association entails how closely the points fall to a recognizable pattern such as a line  </li>                                                        |
|                |                                                                                                                                                                 | <li>*Unusual observations* that do not fit the pattern of the rest of the observations and which are worth examining in more detail </li></ul>                               |
+----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|**Numerically** | Compute and report summary statistics e.g., mean, standard deviation, median, min, max, etc.                                                                    | Compute and report the correlation coefficient.                                                                                                                              |
|  <br>          | <br>                                                                                                                                                            | <br>                                                                                                                                                                         |
|  <br>          | <br>                                                                                                                                                            | <br>                                                                                                                                                                         |
|                | You could, for example, calculate summary statistics such as the mean (`mean()`) and standard deviation (`sd()`), etc. within `summarize()`                     | <br>                                                                                                                                                                         |
|                |                                                                                                                                                                 | You can use the `cor()` function to calculate this                                                                                                                           |   
+----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


## Numeric Exploration

### Descriptives 

`r optbegin("Descriptives Tables", olabel=FALSE,toggle=params$TOGGLE)`

There are numerous packages available that allow us to pull out descriptive statistics from our data set such as **tidyverse** and **psych**.

When we pull out descriptive statistics, it is useful to present these in a well formatted table for your reader. There are lots of different ways of doing this, but one of the most common (and straightforward!) is to use the `kable()` function from the package **kableExtra**. 

This allows us to give our table a clear caption (via `caption = "insert caption here"`, align values within columns e.g., center aligned via `align = "??"`), and we can also round to however many decimal places we desire (standard for APA is 2 dp; via `digits = ??`). 

We can also add in the function `kable_styling()`. This is really helpful for customsing your table e.g., the font size, position, and whether or not you want the table full width (as well as lots of other things - check out the helper function!). 

`r optend()`

`r optbegin("Descriptives Tables - Examples", olabel=FALSE,toggle=params$TOGGLE)`

::: {.panel-tabset}

##### The **tidyverse** way

We can use the `summarise()` function to numerically summarise/describe our data. Some key values we may want to consider extracting are (though not limited to): the mean (via `mean()`, standard deviation (via `sd()`), minimum value (via `min()`), maximum value (via `max()`), standard error (via `se()`), and skewness (via `skew()`). 

For example:

```{r}
library(tidyverse)
library(kableExtra)

# using the pre-loaded iris dataset
# taking the mean and standard deviation of sepal length via the summarize function
# returning a table with a caption, where numbers are rounded to 2 dp
# asking for a table that is not the full width of the window display
iris %>%
    summarize(
        M_Length = mean(Sepal.Length),
        SD_Length = sd(Sepal.Length)
    ) %>%
    kable(caption = "Sepal Length Descriptives (in cm)", digits = 2) %>%
    kable_styling(full_width = FALSE)
```


##### The **psych** way

The `describe()` function will produce a table of descriptive statistics. If you would like only a subset of this output (e.g., mean, sd), you can use `select()` after calling `describe()` e.g., `describe() %>% select(mean, sd)`.

For example:

```{r}
library(psych)
library(kableExtra)

# using the pre-loaded iris dataset
# we want to get descriptive statistics of the iris dataset, specifically the sepal length column
# we specifically want to select the mean and standard deviation from the descriptive statistics available (try this without including this argument to see what values you all get out)
# returning a table with a caption, where numbers are rounded to 2 dp
# asking for a table that is not the full width of the window display
describe(iris$Sepal.Length) %>%
    select(mean, sd) %>%
    kable(caption = "Sepal Length Descriptives (in cm)", digits = 2) %>%
    kable_styling(full_width = FALSE)
```


:::

`r optend()`

#### Correlation

`r optbegin("Correlation Coefficient", olabel=FALSE,toggle=params$TOGGLE)`

The correlation coefficient is a standardised number which quantifies the strength and direction of the linear association between two variables. In a population it is denoted by $\rho$, and in a sample it is denoted by $r$. 

Values of $r$ fall between $-1$ and $1$. How to interpret:

+ Size: More extreme values (i.e., the The closer $r$ is to $+/- 1$) the stronger the linear association, and the closer to $0$ a weak/no association. Commonly used cut-offs are:
    + Weak = $.1 < |r| < .3$
    + Moderate = $.3 < |r| < .5$
    + Strong = $|r| > .5$
    
+ Direction: The sign of $r$ says nothing about the strength of the association, but its naure and direction:
    + Positive association means that values of one variable tend to be higher when values of the other variable are higher
    + Negative association means that values of one variable tend to be lower when values of the other variable are higher

`r optend()`

`r optbegin("Correlation Matrix", olabel=FALSE,toggle=params$TOGGLE)`

A table showing the correlation coefficients - $r_{(x,y)}=\frac{\mathrm{cov}(x,y)}{s_xs_y}$ - between variables. Each cell in the table shows the association between two variables. The diagonals show the correlation of a variable with itself (and are therefore always equal to 1).  

:::blue
**In R**

We can create a correlation matrix by giving the `cor()` function a dataframe. It is important to remember that all variables **must** be numeric.
:::

Let's check the structure of the iris dataset to ensure that all variables are numeric:

```{r}
str(iris)
```

We can see that the variable *Species* in column 5 is a factor - this means that we cannot include this in our correlation matrix. Therefore, we need to *subset*, or, in other words, select specific columns. We can do this either giving the column numbers inside `[]`, or using `select()`. In our case, we want the variables in columns 1 - 4, just not 5.

If you had `NA` values within your dataset, you could choose to remove these `NA`s using `na.rm = TRUE` inside the `cor()` function.

::: {.panel-tabset}

## Index dataframe (`[]`)

```{r}
round(cor(iris[,c(1:4)]), digits = 2)
```

## Variable selection (`select()`)

```{r}
# select only the columns we want by variable name, and pass this to cor()
iris %>% 
  select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) %>%
  cor() %>%
  round(digits = 2)
```

:::

`r optend()`

`r optbegin("Correlation - Hypothesis Testing", olabel=FALSE,toggle=params$TOGGLE)`

The hypotheses of the correlation test are, as always, statements about the _population_ parameter (in this case the correlation between the two variables in the population - i.e., $\rho$).  

If we are conducting a two tailed test, then... 

- $H_0: \rho = 0$. There is _no_ linear association between $x$ and $y$ in the population.  
- $H_1: \rho \neq 0$ There is a linear association between $x$ and $y$.  
  
If we instead conduct a one-tailed test, then we are testing either...

- $H_0: \rho \leq 0$ There is a negative or no linear association between $x$ and $y$   
- $H_1: \rho > 0$ There is a positive linear association between $x$ and $y$.

**OR**

- $H_0: \rho \geq 0$ There is a positive or no linear association between $x$ and $y$   
- $H_1: \rho < 0$ There is a negative linear association between $x$ and $y$.  

__Test Statistic__  

The  test statistic for this test is the $t$ statistic, the formula for which depends on both the observed correlation ($r$) and the sample size ($n$):

$$t = r \sqrt{\frac{n-2}{1-r^2}}$$


__p-value__  

We calculate the $p$-value for our $t$-statistic as the long-run probability of a $t$-statistic with $n-2$ degrees of freedom being less than, greater than, or more extreme in either direction (depending on the direction of our alternative hypothesis) than our observed $t$-statistic.  

__Assumptions__  

For a test of Pearson's correlation coefficient $r$, we need to make sure a few conditions are met:  

+ Both variables are quantitative (i.e., numeric)
+ Both variables are drawn from normally distributed populations
+ The association between the two variables is linear  

`r optend()`

`r optbegin("Correlation - Hypothesis Testing in R", olabel=FALSE,toggle=params$TOGGLE)`

:::blue
**In R**

We can test the significance of the correlation coefficient really easily with the function `cor.test()`:

```{r}
cor.test(iris$Sepal.Length, iris$Petal.Length)
```

Note, by default, `cor.test()` will include only observations that have no missing data on either variable. 

We can specify whether we want to conduct a one- or two-tailed test by adding the argument `alternative = ` and specifying `alternative = "less"`, `alternative = "greater"`, or `alternative = "two.sided"` (the latter being the default).  

:::

::: {.callout-important icon=false appearance="minimal"}

**Example Interpretation**

There was a strong positive association between sepal length and petal length $(r = .87, t(148) = 21.65, p < .001)$. These results suggested that a greater sepal length was positively associated with a greater petal length. 

:::

:::{.callout-note}

For a detailed recap of all things correlation (including further details and examples), revisit the [Correlation lecture from DAPR1](https://uoepsy.github.io/dapr1/2324/lectures/dapR1_lec20_Correlation.pdf).

:::

`r optend()`

## Visual Exploration

`r optbegin("How to Visualise Data", olabel=FALSE,toggle=params$TOGGLE)`

To visualise (i.e., plot) our data, we can use `ggplot()` from the **tidyverse** package. Note the key components of the `ggplot()` code:

+ `data =` where we provide the name of the dataframe.
+ `aes =` where we provide the aesthetics. These are things which we map from the data to the graph. For instance, the $x$-axis, or if we wanted to colour the columns/bars according to some aspect of the data.
+ `+ geom_...` = where we add (using +) some geometry. These are the shapes (e.g., bars, points, etc.), which will be put in the correct place according to what we specified in `aes()`.
+ `labs()` = where we provide labels for our plot (e.g., the $x$- and $y$-axis)


:::{.callout-note}

There are lots of arguments that you can further customise, some of which are specified in the examples below e.g., `bins = `, `alpha = `, `fill = `, `linewidth = `. `linetype = `, `size = ` etc. For these, you can look up the helper function to see the range of arguments they can take using `?` - e.g., `?fill`

If you'd like to read more about `ggplot()`, there is a handy [cheatsheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf).

:::

`r optend()`

`r optbegin("Data Visualisation - Marginal Examples", olabel=FALSE,toggle=params$TOGGLE)`

::: {.panel-tabset}

#### Histogram

A histogram shows the frequency of values which fall within bins of an equal width. 

**Basic:**

- x-axis: possible values of some variable, grouped into bins
- y-axis: frequency of a given value or values within bins
- *What are bins?*: A bin represents a range of scores

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_histogram() +
    labs(x = "Sepal Length (in cm)")
```


**Updating Bins:**

Within `geom_histogram()`, we can specify `bins = ` to specify the number of columns we want (for this example, lets say we want 10):

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_histogram(bins = 10) +
    labs(x = "Sepal Length (in cm)")
```

Alternatively, we can specify `binwidth = ` to specify the width of each bin (it is very helpful to be aware of the scale of your variable here!):

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_histogram(binwidth = 0.1) +
    labs(x = "Sepal Length (in cm)")
```


**Outline columns with color:**

Within `geom_histogram()`, we can specify `color = ` to set a colored outline of the columns:

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_histogram(color = "red") +
    labs(x = "Sepal Length (in cm)")
```


**Fill columns with color:**

Within `geom_histogram()`, we can specify `fill = ` to fill the columns with a color:

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_histogram(fill = "purple") +
    labs(x = "Sepal Length (in cm)")
```

#### Density

A visualization of the distribution of a numeric variable. 

**Basic:**

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_density() +
    labs(x = "Sepal Length (in cm)")
```

**Filled:**

We can fill our plot with colour by specifying `fill = ` within `geom_density()`:

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_density(fill = "lightblue") +
    labs(x = "Sepal Length (in cm)")
```

**Line Type & Width:**

We can change the type and width of the line by specifying `linetype = ` and `linewidth = ` within `geom_density()`:

```{r}
ggplot(data = iris, aes(x = Sepal.Length)) +
    geom_density(linetype = 6, linewidth = 3) +
    labs(x = "Sepal Length (in cm)")
```

:::

`r optend()`

`r optbegin("Data Visualisation - Bivariate Examples", olabel=FALSE,toggle=params$TOGGLE)`

Here we will want to comment on any key observations that we notice, including if we detect outliers or points that do not fit with the pattern in the rest of the data.

::: {.panel-tabset}

#### Scatterplot

We can use a scatterplot (since the variables are numeric and continuous) to visualise the association between the two numeric variables - these will be our x- and y-axis values. 

We plot these values for each row of our dataset, and we should end up with a *cloud* of scattered points. 

Here we will want to comment on any key observations that we notice, including if we detect outliers or points that do not fit with the pattern in the rest of the data. Outliers are extreme observations that are not possible values of a variable or that do not seem to fit with the rest of the data. This could either be:

+ *marginally* along one axis: points that have an unusual (too high or too low) x-coordinate or y-coordinate;
+ *jointly*: observations that do not fit with the rest of the point cloud 

**Basic:**

We need to specify `+ geom_point()` to get a scatterplot: 

```{r}
ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +
    geom_point() +
    labs(x = "Petal Length (in cm)", y = "Sepal Length (in cm)")
```

**Fill points with color:**

Within `geom_point()`, we can specify `fill = ` to fill the points with a color:

```{r}
ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +
    geom_point(color = "orange") +
    labs(x = "Petal Length (in cm)", y = "Sepal Length (in cm)")
```

**Change size and opacity:**

We can change the size (using `size =`) and the opacity (using `alpha =`) of our geom elements on the plot. Let’s include this below:

```{r}
ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +
    geom_point(size = 3, alpha = 0.5) +
    labs(x = "Petal Length (in cm)", y = "Sepal Length (in cm)")
```

**Add a line of best fit:**

We can superimpose (i.e., add) a line of best fit by including the argument `+ geom_smooth()`. Since we want to fit a straight line, we want to use `method = "lm"`. We can also specify whether we want to display confidence intervals around our line by specifying `se = TRUE / FALSE`. 

```{r}
ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    labs(x = "Petal Length (in cm)", y = "Sepal Length (in cm)")
```

:::

`r optend()`

<div class="divider div-transparent div-dot"></div>

# Functions and Mathematical Models

`r optbegin("Identification & Specification", olabel=FALSE,toggle=params$TOGGLE)`

Consider the function $y = 2 + 5 \ x$. From this, we can do the following:

- Identify the dependent variable (DV)
- Identify the independent variable (IV)
- Describe in words what the function does, and compute the output for the following input:

$$
x = \begin{bmatrix}
2 \\
6
\end{bmatrix}
$$

The function says that the $y$ value is obtained as a transformation of the $x$ value.

- The dependent variable is $y$
- The independent variable is $x$
- The $y$ value is obtained as five times $x$, plus two.

<br />
Example (1): If $x$ equals 2, the corresponding value of $y$ will be $2 + 5 * 2 = 12$.
<br />
Example (2): If $x$ equals 6, the corresponding value of $y$ will be $2 + 5 * 6 = 32$.

$$
y = \begin{bmatrix}
2 + 5 * 2 \\
2 + 5 * 6
\end{bmatrix}
= \begin{bmatrix}
12 \\
32
\end{bmatrix}
$$

`r optend()`

`r optbegin("Deterministic Models - Description & Specification", olabel=FALSE,toggle=params$TOGGLE)`

We come across functions *a lot* in daily life, and probably don't think much about it. In a slightly more mathematical setting, we can write down in words and in symbols the function describing the association between the side of a square and its perimeter (e.g., to capture *how* the perimeter *varies* as a function of its side). In this case, the perimeter is the dependent variable, and the side is the independent variable.

This is what we would refer to as a *deterministic model*, as it is a model of an *exact relationship* - there can be no deviation.

**Model Specification**

::: {.panel-tabset}

## In words

The perimeter of a square is four times the length of its side.


## In symbols

The relationship between side and perimeter of squares is given by:

$$
Perimeter = 4 * Side
$$

If you denote $y$ as the dependent variable _Perimeter_, and $x$ as the independent variable _Side_ we cam write rewrite as: 

$$
y = 4 * x
$$
:::

`r optend()`

`r optbegin("Deterministic Models - Visualisation", olabel=FALSE,toggle=params$TOGGLE)`

Let's create a data set called `squares`, containing the perimeter of four squares having sides of length $0, 2, 5, 9$ metres, and then plot the `squares` data as points on a scatterplot. 

First, let's make our squares data. Here we will use two important functions - `tibble()` and `c()`. The `tibble()` function allows us to construct a data frame. To store a sequence of numbers into R, we can **c**ombine the values using `c()`. A sequence of elements all of the same type is called a *vector*.

```{r}
#create data frame named squares
squares <- tibble(
  side = c(0, 2, 5, 9), 
  perimeter = 4 * side
)

#check that our values are contained within squares
squares
```

Now we know how `ggplot()` works, we can start to build our plot. First we specify our data (we want to use the *squares* data frame), and then our aesthetics. Since the perimeter varies as a function of side, we want side on the $x$-axis, and perimeter on the $y$-axis. We want to create a scatterplot, so we need to specify our `geom_...` argument as `geom_point()`. Lastly, we will provide clearer axis labels, and include the units of measurement. 

```{r}
#| label: fig-squares1

ggplot(data = squares, aes(x = side, y = perimeter)) +
  geom_point() +  
  labs(x = 'Side (m)', y = 'Perimeter (m)',  title = 'Perimeter = 4*Side')  
```

We could also visualise the functional relationship by connecting the individual points with a line. To do so, we need to add a new argument - `geom_line()`. If you would like to change the colour of the line from the default, you can specify `geom_line(colour = "insert colour name")`. 

```{r}
ggplot(data = squares, aes(x = side, y = perimeter)) +
  geom_point() +
  geom_line(colour = "blue") + 
  labs(x = 'Side (m)', y = 'Perimeter (m)',  title = 'Perimeter = 4*Side')  
```

`r optend()`

`r optbegin("Deterministic Models - Predicted Values", olabel=FALSE,toggle=params$TOGGLE)`

Sometimes we can directly read a predicted value from the graph of the functional relationship.

Consider the plot created above. For example, first we need to check where x = 2.5. Then, we draw a vertical dashed line until it meets the blue line. The y value corresponding to x = 2.5 can be read off the y-axis. In our case, we would say a side of 2.5m corresponds to a perimeter of 10m. 

However, in this case it is not that easy to read it from the drawing... This leads us to the algebraic approach:

We can substitute the x value in the formula and calculate the corresponding y value where we would conclude that the predicted perimeter of squared paintings having a 2.5m side is 10m:

$$
y = 4 \cdot x  \\    
$$

$$
y = 4 \cdot 2.5 \\  
$$

$$
y = 10  \\
$$
`r optend()`

<div class="divider div-transparent div-dot"></div>

# Statistical Models

`r optbegin("Statistical Models - Description & Specification", olabel=FALSE,toggle=params$TOGGLE)`

The association between two variables (e.g., height and handspan) will show deviations from the 'average pattern'. Hence, we need to create a model that allows for deviations from the linear relationship - we need a _statistical model_.

A statistical model includes *both* a deterministic function and a random error term. We typically refer to the outcome (‘dependent’) variable with the letter $y$ and to our predictor (‘explanatory’/‘independent’) variables with the letter $x$. A simple (i.e., one x variable only) linear regression model thus takes the following form (where the terms $\beta_0$ and $\beta_1$ are numbers specifying where the line going through the data meets the y-axis (i.e., the intercept - where $x$ = 0; $\beta_0$) and its slope (direction and gradient of line; $\beta_1$):

**Model Specification**

$$
y_i = \beta_0 + \beta_1 \cdot x_i + \epsilon_i    
$$

**Model Specification: Annotated**

$$
y_i = \underbrace{\beta_0 + \beta_1 \cdot x_i}_{\text{function of }x} + \underbrace{\epsilon_i}_{\text{random error}}  
\\
$$

$$
\quad \text{where} \quad \epsilon_i \sim N(0, \sigma) \text{ independently}
$$


**Model Specification: Explained**

Let's break down what $y_i = \beta_0 + \beta_1 \cdot x_i + \epsilon_i \quad \text{where} \quad \epsilon_i \sim N(0, \sigma) \text{ independently}$ actually means by considering the statement in smaller parts:

+ *$y_i = \beta_0 + \beta_1 \cdot x_i + \epsilon_i$*  
  
    + $y_i$ is our measured outcome variable (our DV)  
    + $x_i$ is our measured predictor variable (our IV)  
    + $\beta_0$ is the model intercept  
    + $\beta_1$ is the model slope  

+ *$\epsilon \sim N(0, \sigma) \text{ independently}$*   
  
    + $\epsilon$ is the residual error   
    + $\sim$ means 'distributed according to'    
    + $N(0, \sigma) \text{ independently}$ means 'normal distribution with a mean of 0 and a variance of $\sigma$'   
    + Together, we can say that the errors around the line have a mean of zero and constant spread as x varies    


:::blue
**In R**

There are basically two pieces of information that we need to pass to the `lm()` function:

1. The formula: The regression formula should be specified in the form `y ~ x` where $y$ is the dependent variable (DV) and $x$ the independent variable (IV).
2. The data: Specify which dataframe contains the variables specified in the formula.

In `R`, the syntax of the lm() function can be specified as follows (where DV = dependent variable, IV = independent variable, and dataframe_name = the name of your dataset):

::: {.panel-tabset}

## Option A

```{r eval=FALSE}
model_name <- lm(DV ~ IV, data = dataframe_name) 
```

## Option B

```{r eval=FALSE}
model_name <- lm(dataframe_name$DV ~ data_name$IV)
```


:::

you can also specify as: 

::: {.panel-tabset}

## Option A

```{r eval=FALSE}
model_name <- lm(DV ~ 1 + IV, data = dataframe_name) 
```

## Option B

```{r eval=FALSE}
model_name <- lm(dataframe_name$DV ~ 1 + data_name$IV)
```

:::

::: {.callout-important icon=false collapse=true}
## Why is there a 1 in the Option B's? 
When we specify the linear model in `R`, we include after the tilde sign ($\sim$), the variables that appear to the right of the $\hat \beta$s. The intercept, or $\beta_0$, is a constant. That is, we could write it as multiplied by 1.

Including the 1 explicitly is not necessary because it is included by default (you can check this by comparing the outputs of A & B above with and without the 1 included - the estimates are the same!). After a while, you will find you just want to drop the 1 (i.e., Option B) when calling `lm()` because you know that it’s going to be there, but in these early weeks we tried to keep it explicit to make it clear that you want to the intercept to be estimated. 
:::

:::

`r optend()`

`r optbegin("Statistical Models - Example", olabel=FALSE,toggle=params$TOGGLE)`

Imagine that you were tasked to investigate how handspan varies as a function of height in a sample of students. Specifically, @Utts2015 provided a dataset (available at https://uoepsy.github.io/data/handheight.csv) for a sample of 167 students which reported their `height` (in inches) and `handspan` (in cm) as part of a class survey. 

We could specify our model as:

$$
Handspan_i = \beta_0 + \beta_1 \cdot Height_i + \epsilon_i    
$$

and fit our model in `R` as

```{r}
#specify model
hand_mdl <- lm(handspan ~ height, data = handheight)

#look at model coefficients
hand_mdl
```



When we call the name of the fitted model, `hand_mdl`, you can see the estimated regression coefficients $\hat \beta_0$ and $\hat \beta_1$. The line of best-fit is thus given by:^[Yes, the error term is gone. This is because the line of best-fit gives you the prediction of the average handspan for a given height, and not the individual handspan of a person, which will almost surely be different from the prediction of the line.] 

$$\widehat{Handspan} = -3 + 0.35 \cdot Height$$

`r optend()`

`r optbegin("Statistical Models - Extracing Information", olabel=FALSE,toggle=params$TOGGLE)`

::: {.panel-tabset}

## Model Coefficients

Our model coefficients help us to build our best fitting equation of the line that represents the association between our DV and our IV(s). 

There are numerous equivalent ways to obtain the estimated regression coefficients --- that is, $\hat \beta_0$, $\hat \beta_1$, ...., $\hat \beta_k$ --- from the fitted model (for this example, our fitted model has been named `mdl`):

- `mdl`
- `mdl$coefficients`
- `coef(mdl)`
- `coefficients(mdl)`
- `summary(mdl)`

## $\sigma$

The standard deviation of the errors, denoted by $\sigma$, is an important quantity that our model estimates. It represents how much individual data points tend to deviate above and below the regression line - in other words, it tells us how much uncertainty there is with our coefficient. 

A small $\sigma$ indicates that the points hug the line closely and we should expect fairly accurate predictions, while a large $\sigma$ suggests that, even if we estimate the line perfectly, we can expect individual values to deviate from it by substantial amounts.

The *estimated* standard deviation of the errors is denoted $\hat \sigma$, and is estimated by essentially averaging squared residuals (giving the variance) and taking the square-root: 

$$
\begin{align}
& \hat \sigma = \sqrt{\frac{SS_{Residual}}{n - k - 1}} \\
\qquad \\
& \text{where} \\
& SS_{Residual} = \textrm{Sum of Squared Residuals} = \sum_{i=1}^n{(\epsilon_i)^2}
\end{align}
$$


There are a couple of equivalent ways to obtain the estimated standard deviation of the errors --- that is, $\hat \sigma$ --- from the fitted model (for this example, our fitted model has been named `mdl`):

- `sigma(mdl)`
- `summary(mdl)`

:::

`r optend()`

`r optbegin("Statistical Models - Visualisation", olabel=FALSE,toggle=params$TOGGLE)`

As we saw above, the line representing the relationship between side and perimeter of squares is able to predict the actual perimeter value from the measurement of the side of a square.  

This is possible because the association between side and perimeter is an **exact** one. That is, any squares having the same side will have the same perimeter, and there will be no variation in those values.

The line that best fits the association between height and handspan (see @fig-handheight-fitted-model), instead, is only able to predict the **average** handspan for a given value of height.

This is because there will be a distribution of handspans at each value of height. The line will fit the trend/pattern in the values, but there will be individual-to-individual variability that we must accept around that average pattern.

```{r}
#| label: fig-handheight-fitted-model
#| fig-cap: "Association between Handspan and Height"

ggplot(handheight, aes(x = height, y = handspan)) + 
    geom_point(size = 3, alpha = 0.5) +
    geom_smooth(method = lm, se = FALSE) + 
    labs(x = "Height (in.)", y = "Handspan (cm.)")
```

`r optend()`

<div class="divider div-transparent div-dot"></div>

# Model Predicted Values & Residuals

`r optbegin("Predicted Values", olabel=FALSE,toggle=params$TOGGLE)`

### Model predicted values ($\hat y_i$) for sample data

We can get out the model predicted values for $y$, the "y hats" ($\hat y$), for the data in the sample using various functions:

- `predict(<fitted model>)`
- `fitted(<fitted model>)`
- `fitted.values(<fitted model>)`
- `mdl$fitted.values`

For example, this will give us the estimated handspan (point on our regression line) for each observed value of hand height for each of our 167 participants.

```{r eval = FALSE}
predict(hand_mdl)
```

For space saving purposes (i.e., we don't need to see all 167 values for this demonstration!), we can return the first six predicted values via `head()`:

```{r}
head(predict(hand_mdl))
```

### Model predicted values for other (unobserved) data

To compute the model-predicted values for unobserved data (i.e., data not contained in the sample), we can use the following function:

- `predict(<fitted model>, newdata = <dataframe>)`

For this example, we first need to remember that the model predicts `handspan` using the independent variable `height`. Hence, if we want predictions for new (unobserved) data, we first need to create a tibble with a column called `height` containing the height of hands for which we want the prediction, and store this as a dataframe.

```{r}
#Create dataframe 'newdata' containing the hand height values of 50, 53, and 82
newdata <- tibble(height = c(50, 53, 82))
newdata
```

Then we take `newdata` and add a new column called `handspan_hat`, computed as the prediction from the fitted `hand_mdl` using the `newdata` above:

```{r}
newdata <- newdata %>%
  mutate(
    handspan_hat = predict(hand_mdl, newdata = newdata)
  )
newdata
```

`r optend()`

`r optbegin("Residuals", olabel=FALSE,toggle=params$TOGGLE)`

The residuals ($\hat \epsilon_i$) represent the deviations between the actual responses and the predicted responses and can be obtained either as

- `mdl$residuals`
- `resid(mdl)`
- `residuals(mdl)`
- computing them as the difference between the response ($y_i$) and the predicted response ($\hat y_i$)

`r optend()`


`r optbegin("Predicted Values - Example", olabel=FALSE,toggle=params$TOGGLE)`

Lets estimate (or predict) handspan of two students with the following heights (a) 73in, and (b) 5in. There are a few ways we can do this:

::: {.panel-tabset}

## Substitute in Values

- The predicted average handspan for students who have heights of 73in is:
<br />
$-3 + (0.35 * 73) = 22.55$cm.
<br />
<br />
- The predicted average handspan for students who have heights of 5in is:
<br />
$-3 + (0.35 * 5) = -1.25$cm. 

## Use `predict()` Function

```{r}
newdata <- tibble(height = c(73, 5))

handspan_hat <- predict(hand_mdl, newdata = newdata)
handspan_hat
```

:::

We can see that both approaches (manually substituting values into the regression equation or using the `predict()` function) both give us the same values. But wait, handspan can not be negative... This *does not* make any sense!

That's right, we went too far off the range of the available data on heights, which were between 57in and 78in. We extrapolated. This is very dangerous...

```{r, echo=FALSE, fig.cap = 'Source: Randall Munroe, xkcd.com'}
knitr::include_graphics('https://imgs.xkcd.com/comics/extrapolating.png')
```

`r optend()`

<div class="divider div-transparent div-dot"></div>


# Data Transformations

There are many transformations we can do to a continuous variable, but far and away the most common ones are centering and scaling.

`r optbegin("Centering", olabel=FALSE,toggle=params$TOGGLE)`

Centering simply means moving the entire distribution to be centered on some new value. We achieve this by subtracting our desired center from each value of a variable. 

A common option is to mean center (i.e. to subtract the mean from each value). This makes our new values all relative to the mean. We can center a variable on other things, such as the minimum or maximum value of the scale we are using, or some judiciously chosen value of interest.

`r optend()`

`r optbegin("Scaling", olabel=FALSE,toggle=params$TOGGLE)`

Scaling changes the units of the variable, and we do this by dividing the observations by some value. E.g., moving from “36 months” to “3 years” involves multiplying (scaling) the value by 1/12.

Far and away the most common transformation that involves scaling is called **standardisation**. 

`r optend()`

`r optbegin("Standardisation", olabel=FALSE,toggle=params$TOGGLE)`

This involves subtracting the mean and then dividing by the standard deviation. So standardisation centers on the sample mean and scales by the sample standard deviation. Recall that a standardized variable has mean of 0 and standard deviation of 1.

**$z$-score Formula:**

$$
z_x = \frac{x - \bar{x}}{s_x}, \qquad z_y = \frac{y - \bar{y}}{s_y}
$$

:::blue

In **R**:

```{r eval = FALSE}
#create z-scored variables and then use these in model
dataframe <- dataframe %>%
  mutate(
   z_variable = (variable - mean(variable)) / sd(variable)
    )

```

**OR**

```{r eval = FALSE}
#use scale function within lm argument
model <- lm(scale(DV) ~ scale(IV), data = dataset)
```

:::

When we standardise variables in a regression model, it means we can talk about all our coefficients in terms of “standard deviation units”. To the extent that it is possible to do so, this puts our coefficients on scales of the similar magnitude, making qualitative comparisons between the sizes of effects a little more easy.

We tend to refer to coefficients using standardised variables as (unsurprisingly), “standardised coefficients”

There are two main ways that people construct standardised coefficients. One of which standardises just the predictor, and the other of which standardises both predictor and outcome:


| predictor    | outcome      | in lm                     | coefficient                    | interpretation                               |
| ------------ | ------------ | ------------------------- | --------------------------------- | -------------------------------------------- |
| standardised | raw          | `y ~ scale(x)`        | $\beta = b \cdot s_x$             | "difference in Y for a 1 SD increase in X"       |
| standardised | standardised | `scale(y) ~ scale(x)` | $\beta = b \cdot \frac{s_x}{s_y}$ | "difference in SD of Y for a 1 SD increase in X" |

`r optend()`


<div class="divider div-transparent div-dot"></div>

# Model Fit

`r optbegin("Sums of Squares", olabel=FALSE,toggle=params$TOGGLE)`

To quantify and assess a model’s utility in explaining variance in an outcome variable, we can split the total variability of that outcome variable into two terms: the variability explained by the model plus the variability left unexplained in the residuals.

The sum of squares measures the deviation or variation of data points away from the mean (i.e., how spread out are the numbers in a given dataset). We are trying to find the equation/function that best fits our data by varying the least from our data points. 

##### Total Sum of Squares

**Formula**: 

$$
SS_{Total} = \sum_{i=1}^{n}(y_i - \bar{y})^2
$$
Can also be derived from:

$$
SS_{Total} = SS_{Model} + SS_{Residual}
$$

**In words**: 

Squared distance of each data point from the mean of $y$.

**Description**: 

How much variation there is in the DV.

##### Residual Sum of Squares

**Formula**: 

$$
SS_{Residual} = \sum_{i=1}^{n}(y_i - \hat{y}_i)^2
$$

**In words**: 

Squared distance of each point from the predicted value.

**Description**: 

How much of the variation in the DV the model did not explain - a measure that captures the unexplained variation in your regression model. Lower residual sum of squares suggests that your model fits the data well, and higher suggests that the model poorly explains the data (in other words, the lower the value, the better the regression model). If the value was zero here, it would suggest the model fits perfectly with no error.

##### Model Sum of Squares

**Formula**: 

$$
SS_{Model} = \sum_{i=1}^{n}(\hat{y}_i - \bar{y})^2
$$

Can also be derived from:

$$
SS_{Model} = SS_{Total} - SS_{Residual}
$$
**In words**: 

The deviance of the predicted scores from the mean of $y$.

**Description**: 

How much of the variation in the DV your model explained - like a measure that captures how well the regression line fits your data.

`r optend()`

`r optbegin("F-ratio", olabel=FALSE,toggle=params$TOGGLE)`

**Overview:**

We can perform a test to investigate if a model is ‘useful’ — that is, a test to see if our explanatory variable explains more variance in our outcome than we would expect by just some random chance variable.  

With one predictor, the $F$-statistic is used to test the null hypothesis that the regression slope for that predictor is zero:

$$
H_0: \text{the model is ineffective, }b_1 = 0 \\  
$$
$$
H_1 : \text{the model is effective, }b_1  \neq 0 \\  
$$

In multiple regression, the logic is the same, but we are now testing against the null hypothesis that **all** regression slopes are zero. Our test is framed in terms of the following hypotheses:

$$ 
H_0: \text{the model is ineffective, }b_1,...., b_k = 0 \\    
$$

$$
H_1 : \text{the model is effective, }b_1,...., b_k  \neq 0 \\  
$$

The relevant test-statistic is the $F$-statistic, which uses “Mean Squares” (these are Sums of Squares divided by the relevant degrees of freedom). We then compare that against (you guessed it) an $F$-distribution! $F$-distributions vary according to two parameters, which are both degrees of freedom.

**Formula:** 

$$
F_{(df_{model},~df_{residual})} = \frac{MS_{Model}}{MS_{Residual}} = \frac{SS_{Model}/df_{Model}}{SS_{Residual}/df_{Residual}} \\
\quad \\
$$

$$
\begin{align}
& \text{Where:} \\
& df_{model} = k \\
& df_{residual} = n-k-1 \\
& n = \text{sample size} \\
& k  = \text{number of explanatory variables} \\
\end{align}
$$


**Description:**

To test the significance of an overall model, we can conduct an $F$-test. The $F$-test compares your model to a model containing zero predictor variables (i.e., the intercept only model), and tests whether your added predictor variables significantly improved the model.

It is called the $F$-ratio because it is the ratio of the how much of the variation is explained by the model (per paramater) versus how much of the variation is unexplained (per remaining degrees of freedom). 

The $F$-test involves testing the statistical significance of the $F$-ratio.   

**Q:** What does the $F$-ratio test?  
**A:** The null hypothesis that all regression slopes in a model are zero (i.e., explain no variance in your outcome/DV). The alternative hypothesis is that **at least one of the slopes is not zero**. 


The $F$-ratio you see at the bottom of `summary(model)` is actually a comparison between two models: your model (with some explanatory variables in predicting $y$) and the *null model*. 

In regression, the null model can be thought of as the model in which all explanatory variables have zero regression coefficients. It is also referred to as the __intercept-only model__, because if all predictor variable coefficients are zero, then the only we are only estimating $y$ via an intercept (which will be the mean - $\bar y$). 

**Interpretation:** 

Alongside viewing the $F$-ratio, you can see the results from testing the null hypothesis that all of the coefficients are $0$ (the alternative hypothesis is that at least one coefficient is $\neq 0$. Under the null hypothesis that all coefficients = 0, the ratio of explained:unexplained variance should be approximately 1)

If your model predictors do explain some variance, the $F$-ratio will be significant, and you would reject the null, as this would suggest that your predictor variables included in your model improved the model fit (in comparison to the intercept only model).


*Points to note:*

- The larger your $F$-ratio, the better your model
- The $F$-ratio will be close to 1 when the null is true (i.e., that all slopes are zero)

:::blue

In **R**

We can see the $F$-statistic and associated $p$-value at the bottom of the output of `summary(<modelname>)`:

```{r mlroutputf, echo=FALSE, fig.cap="Multiple regression output in R, F statistic highlighted", fig.align = 'left'}
knitr::include_graphics("images/mlr_fstat.PNG")
```

:::

::: {.callout-important icon=false appearance="minimal"}

**Example Interpretation**

The linear model with social interactions and outdoor time explained a significant amount of variance in wellbeing scores beyond what we would expect by chance $F(2, 197) = 14.26, p < .001)$. 

:::

`r optend()`

`r optbegin("R-squared and Adjusted R-squared", olabel=FALSE,toggle=params$TOGGLE)`

**Overview:**

$R^2$ represents the proportion of variance in $Y$ that is explained by the model predictor variables. 

**Formula:**

The $R^2$ coefficient is defined as the proportion of the total variability in the outcome variable which is explained by our model:
$$
R^2 = \frac{SS_{Model}}{SS_{Total}} = 1 - \frac{SS_{Residual}}{SS_{Total}}
$$

The Adjusted $R^2$ coefficient is defined as:
$$
\hat R^2 = 1 - \frac{(1 - R^2)(n-1)}{n-k-1}
\quad \\
$$

$$
\begin{align}
& \text{Where:} \\
& n = \text{sample size} \\
& k = \text{number of explanatory variables} \\
\end{align}
$$

<br>

**When to report Multiple $R^2$ vs. Adjusted $R^2$:**

The Multiple $R^2$ value should be reported for a simple linear regression model (i.e., one predictor).   

Unlike $R^2$, Adjusted-$R^2$ does not necessarily increase with the addition of more explanatory variables, by the inclusion of a penalty according to the number of explanatory variables in the model. Since Adjusted-$R^2$ is adjusted for the number of predictors in the model, this should be used when there are 2 or more predictors in the model. As a side note, the Adjusted-$R^2$ should always be less than or equal to $R^2$.


:::blue

In **R**

We can see both $R^2$ and Adjusted-$R^2$ in the second bottom row of the `summary(<modelname>)`:

```{r mlroutputr, echo=FALSE, fig.cap="Multiple regression output in R, R^2 statistic highlighted", fig.align = 'left'}
knitr::include_graphics("images/mlr_rstat.PNG")
```

:::

::: {.callout-important icon=false appearance="minimal"}

**Example Interpretation**

Together, social interactions and outdoor time explained approximately 11.76% of the variance in wellbeing scores. 

:::

`r optend()`

<div class="divider div-transparent div-dot"></div>

# Model Comparisons

One useful thing we might want to do is compare our models with and without some predictor(s).There are numerous ways we can do this, but the method chosen depends on the models and underlying data:

```{r comparisons_chart, echo=FALSE, fig.align = 'left', out.width = "100%"}
knitr::include_graphics("images/comparisons_chart.png")
```

`r optbegin("Nested vs Non-Nested Models", olabel=FALSE,toggle=params$TOGGLE)`

**Nested Models**

Consider that you have two regression models where Model 1 contains a subset of the predictors contained in the other Model 2 and is fitted to the same data. More simply, Model 2 contains all of the predictors included in Model 1, **plus** additional predictor(s). This means that Model 1 is *nested* within Model 2, or that Model 1 is a *submodel* of Model 2. These two terms, at least in this setting, are interchangeable - it might be easier to think of Model 1 as your null and Model 2 as your alternative.

**Non-Nested Models**

Consider that you have two regression models where Model 1 contains different variables to those contained in Model 2, where both models are fitted to the same data. More simply, Model 1 and Model 2 contain unique variables that are not shared. This means that Model 1 and Model 2 are **not** nested.

`r optend()`

`r optbegin("Incremental F-test", olabel=FALSE,toggle=params$TOGGLE)`

If (*and only if*) two models are __nested__, can we compare them using an __incremental F-test__.  

This is a formal test of whether the additional predictors provide a better fitting model.  
Formally this is the test of:  

+ $H_0:$ coefficients for the added/omitted variables are all zero.

+ $H_1:$ at least one of the added/omitted variables has a coefficient that is not zero. 

The $F$-ratio for comparing the residual sums of squares between two models can be calculated as:

$$
F_{(df_R-df_F),~df_F} = \frac{(SSR_R-SSR_F)/(df_R-df_F)}{SSR_F / df_F} \\
\quad \\
$$
$$
\begin{align}
& \text{Where:} \\
\\
& SSR_R = \text{residual sums of squares for the restricted model} \\
& SSR_F = \text{residual sums of squares for the full model} \\
& df_R = \text{residual degrees of freedom from the restricted model} \\
& df_F = \text{residual degrees of freedom from the full model} \\
\end{align}
$$

:::blue
**In R**

We can conduct an incremental $F$-test using the `anova()` function:

```{r, eval = FALSE}

anova(<model1name>, <mode21name>)

```


:::


`r optend()`

`r optbegin("AIC & BIC", olabel=FALSE,toggle=params$TOGGLE)`

AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion) combine information about the sample size, the number of model parameters, and the residual sums of squares ($SS_{residual}$). Models do not *need* to be nested to be compared via AIC and BIC, __but__ they need to have been fit to the same dataset.  

For both of these fit indices, lower values are better, and both include a penalty for the number of predictors in the model (although BIC's penalty is harsher):

$$
\begin{align}
AIC = n\,\text{ln}\left( \frac{SS_{residual}}{n} \right) + 2k \\
\end{align}
\quad \\
$$

$$
\begin{align}
BIC = n\,\text{ln}\left( \frac{SS_{residual}}{n} \right) + k\,\text{ln}(n) \\
\end{align}
\quad \\
$$

$$
\begin{align}
& \text{Where:} \\
& SS_{residual} = \text{sum of squares residuals} \\
& n = \text{sample size} \\
& k = \text{number of explanatory variables} \\
& \text{ln} = \text{natural log function} 
\end{align}
$$

:::blue
**In R**

We can calculate AIC and BIC by using the `AIC()` and `BIC()` functions respectively:

```{r, eval = FALSE}
#AIC
AIC(<modelname>)

#BIC
BIC(<modelname>)

```


:::


`r optend()`















